

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Multiscale representation &mdash; MultiScaleOT 0.3.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Auxillary objects for Sinkhorn solvers" href="reference_solver_aux.html" />
    <link rel="prev" title="Module reference" href="reference.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> MultiScaleOT
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Module reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Multiscale representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference_solver_aux.html">Auxillary objects for Sinkhorn solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference_solver_standard.html">Sinkorn solver (standard)</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference_solver_unbalanced.html">Sinkorn solver (unbalanced)</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference_solver_barycenter.html">Barycenters</a></li>
<li class="toctree-l2"><a class="reference internal" href="reference_periphery.html">Periphery functions and classes</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MultiScaleOT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="reference.html">Module reference</a> &raquo;</li>
        
      <li>Multiscale representation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/reference_multiscale.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="multiscale-representation">
<h1>Multiscale representation<a class="headerlink" href="#multiscale-representation" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="MultiScaleOT.TMultiScaleSetup">
<em class="property">class </em><code class="sig-prename descclassname">MultiScaleOT.</code><code class="sig-name descname">TMultiScaleSetup</code><a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiscale representation of a measure supported on a point cloud.</p>
<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, pos: numpy.ndarray[numpy.float64], mu: numpy.ndarray[numpy.float64], depth: int, childMode: int = 1, setup: bool = True, setupDuals: bool = True, setupRadii: bool = True</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – 2d double array of point locations where the measure is supported</p></li>
<li><p><strong>mu</strong> – 1d double array of point masses</p></li>
<li><p><strong>depth</strong> – multiscale representation will have depth+1 layers. depth=0 means no multiscale representation, just the original point cloud.</p></li>
<li><p><strong>childMode</strong> – <p>determines the order of children nodes in intermediate layers.</p>
<ul>
<li><p>0 (=tree): adaptive 2^n tree where empty branches are discarded</p></li>
<li><p>1 (=grid): every layer is assumed to be a full Cartesian grid, nodes are numbered and stored in C order. Simpler if applicable, only works if all nodes are actually required.</p></li>
</ul>
</p></li>
<li><p><strong>setup</strong> – whether constructor automatically runs basic setup() method</p></li>
<li><p><strong>setupDuals</strong> – whether constructor allocates storage for dual variables (can be done later with method setupDuals() )</p></li>
<li><p><strong>setupRadii</strong> – whether constructor computes radii of hierarchical partition cells (can be done later with setupRadii() )</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.coarsenSignal">
<code class="sig-name descname">coarsenSignal</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, signal: numpy.ndarray[numpy.float64], lFinest: int, lCoarsest: int, mode: int</em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.coarsenSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Coarsens a double-valued signal from one layer to subsequent coarser layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> – 1d double array with signal at finest layer</p></li>
<li><p><strong>lFinest</strong> – id of finest layer</p></li>
<li><p><strong>lCoarsest</strong> – id of coarsest layer</p></li>
<li><p><strong>mode</strong> – <p>determines how signal is refined.</p>
<ul>
<li><p>0: coarse value is min over children</p></li>
<li><p>1: coarse value is max over children</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of double array containing coarsened signal at requested layers.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.coarsenSignalInt">
<code class="sig-name descname">coarsenSignalInt</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, signal: numpy.ndarray[numpy.int32], lFinest: int, lCoarsest: int, mode: int</em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.coarsenSignalInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Coarsens a int32-valued signal from one layer to subsequent coarser layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> – 1d int32 array with signal at finest layer</p></li>
<li><p><strong>lFinest</strong> – id of finest layer</p></li>
<li><p><strong>lCoarsest</strong> – id of coarsest layer</p></li>
<li><p><strong>mode</strong> – <p>determines how signal is refined.</p>
<ul>
<li><p>0: coarse value is min over children</p></li>
<li><p>1: coarse value is max over children</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of double array containing coarsened signal at requested layers.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getChildren">
<code class="sig-name descname">getChildren</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em>, <em class="sig-param">id: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.int32]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of children of node id at layer nLayer.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getDepth">
<code class="sig-name descname">getDepth</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getDepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the depth parameter of the TMultiScaleSetup instance (which is &lt;number of layers&gt;-1).</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getDual">
<code class="sig-name descname">getDual</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getDual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dual variable values at layer nLayer.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getMeasure">
<code class="sig-name descname">getMeasure</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getMeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get measure at layer nLayer. If nLayer==nLayers-1==depth it returns the original measure.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getNLayers">
<code class="sig-name descname">getNLayers</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getNLayers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of layers of the TMultiScaleSetup instance (which is depth+1).</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getNPoints">
<code class="sig-name descname">getNPoints</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getNPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get number of points at layer nLayer.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getParents">
<code class="sig-name descname">getParents</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.int32]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getParents" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parents of nodes at layer nLayer.</p>
<p>Returns zeros at coarsest layer, nLayer=0.
At finer layers returns array of int32 of size of current layer. Each entry gives id of parent node in parent layer. This id is location of the parent node in points or measure arrays.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getPoints">
<code class="sig-name descname">getPoints</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get points at layer nLayer. If nLayer==nLayers-1==depth it returns the original point cloud.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.getRadii">
<code class="sig-name descname">getRadii</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">nLayer: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.getRadii" title="Permalink to this definition">¶</a></dt>
<dd><p>Get radii at layer nLayer. Only valid for nLayer&lt;=nLayers-2 since there are no radii on finest layer.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.refineSignal">
<code class="sig-name descname">refineSignal</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, signal: numpy.ndarray[numpy.float64], lTop: int, mode: int = 0</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64]<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.refineSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Refines a hierarchical signal from one layer to the subsequent finer layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> – 1d double array with signal at coarse layer</p></li>
<li><p><strong>lTop</strong> – id of coarse layer</p></li>
<li><p><strong>mode</strong> – <p>determines how signal is refined.</p>
<ul>
<li><p>0: fine value equals parent value (default)</p></li>
<li><p>1: fine value is interpolated piecewise linearly (only works on Cartesian grids constructed with childMode=grid, experimental))</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1d double array containing refined signal at fine layer (one layer below coarse layer)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setChildModeGrid">
<code class="sig-name descname">setChildModeGrid</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setChildModeGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets childMode to 0 (=tree). Only meaningful before setup() is called, see constructor.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setChildModeTree">
<code class="sig-name descname">setChildModeTree</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setChildModeTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets childMode to 1 (=grid). Only meaningful before setup() is called, see constructor.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setDual">
<code class="sig-name descname">setDual</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, alpha: numpy.ndarray[numpy.float64], nLayer: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setDual" title="Permalink to this definition">¶</a></dt>
<dd><p>Set dual variable at layer nLayer to alpha and then propagates values to all coarser layers by maximization over child nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> – 1d double array with new values for dual variable. Size needs to equal number of cells in that layer.</p></li>
<li><p><strong>nLayer</strong> – id of layer on which dual variable is to be set.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setInterpolationMode">
<code class="sig-name descname">setInterpolationMode</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em>, <em class="sig-param">interpolation_mode: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setInterpolationMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental undocumented method.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic setup after calling the constructor. Instance cannot be used without calling this first, but constructor by default calls it automatically. See also constructor.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setupDuals">
<code class="sig-name descname">setupDuals</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setupDuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory for dual variables (at all scales). See also constructor.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.setupRadii">
<code class="sig-name descname">setupRadii</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.setupRadii" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute radii of hierarchical partition cells. See also constructor.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.updateMeasure">
<code class="sig-name descname">updateMeasure</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, newMeasure: numpy.ndarray[numpy.float64]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.updateMeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the point masses of the multi scale representation at the finest layer and internally updates all coarser nodes.</p>
</dd></dl>

<dl class="method">
<dt id="MultiScaleOT.TMultiScaleSetup.updatePositions">
<code class="sig-name descname">updatePositions</code><span class="sig-paren">(</span><em class="sig-param">self: MultiScaleOT.TMultiScaleSetup, newPositions: numpy.ndarray[numpy.float64]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#MultiScaleOT.TMultiScaleSetup.updatePositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the spatial positions of the multi scale representation at the finest layer and internally updates all coarser nodes and radii values.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="reference_solver_aux.html" class="btn btn-neutral float-right" title="Auxillary objects for Sinkhorn solvers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="reference.html" class="btn btn-neutral float-left" title="Module reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Bernhard Schmitzer

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>